module mod_vars

  implicit none
  public
  INTEGER, PARAMETER    :: DP = KIND(1.0d0)
  real(DP), parameter   :: pi = 3.14159265358979323846
  real(DP)              :: dt, xmin, xmax, xmean, stddev, dx, k_0, mass, dtwrite
  real(DP)              :: time = 0.0, norm, energy(3), energy_diff ! energy(total, potential, kinetic)
  real(DP), dimension(:), allocatable    :: x,y,z,point
  !>jj -  extending to many states
  complex(DP), dimension(:), allocatable :: wfp, theta_v1, kin_p1
  complex(DP), dimension(:,:), allocatable :: wfx
  complex(DP), dimension(:,:), allocatable :: wf2p, theta_v2, kin_p2
  complex(DP), dimension(:,:,:), allocatable :: wf2x
  !jj - 
  complex(DP), dimension(:,:,:), allocatable :: wf3p, theta_v3, kin_p3
  complex(DP), dimension(:,:,:,:), allocatable :: wf3x
  !<jj
  !>jj adding field
  logical               :: use_field=.false.
  character(len=100)    :: field=''
  !>jj adding field
  logical               :: project_rot=.true., analytic=.true., print_wf=.true.
  integer               :: run, nstep, ngrid, wf, rank, nstates
  integer               :: iost, i, j, k, istate, jstate, file_unit
  integer ( kind = 8 )  :: plan_forward, plan_backward

  real(DP), dimension(:), allocatable     :: v1, px, py, pz
  real(DP), dimension(:,:), allocatable   :: v2
  real(DP), dimension(:,:,:), allocatable :: v3
  character(len=100)             :: pot=''
  character(len=50)             :: file_name
  character(len=*),dimension(1),parameter :: var1 = (/'x'/)
  character(len=*),dimension(2),parameter :: var2 = (/'x','y'/)
  character(len=*),dimension(3),parameter :: var3 = (/'x','y','z'/)

  namelist /general/run,nstep,dt,dtwrite,ngrid,rank,xmin,xmax,mass,wf,pot,nstates,project_rot,analytic,use_field,field,print_wf

CONTAINS

subroutine read_input()
  implicit none

  write(*,*)
  write(*,*) "### Reading input ###"

!-- Reading input file
  open(100,file='input.q', status='OLD', action='READ',delim='APOSTROPHE', iostat=iost)
  read(100, general, iostat=iost)
  if (iost.ne.0) then
    write(*,*)'ERROR: input.q file must be provided'
    write(*,*) iost
    stop 1
  end if
  close(100)

!-- Input check
  call check()


end subroutine read_input

subroutine check()

! run case (imag/real)
select case(run)
  case(0)
    write(*,*) "RUN: 0 - REAL TIME PROPAGATION"
  case(1)
    write(*,*) "RUN: 1 - IMAGINARY TIME PROPAGATION"
  case default
    write(*,*) "ERR: Unrecongnized run option. Exiting"
    stop 1
end select

! ngrid is power of 2
if ((ngrid .ne. 0) .and. (IAND(ngrid, ngrid-1) .eq. 0))  then
  write(*,'(A,I5)') " Grid size: ",ngrid
else
  write(*,*) "ERR: Grid size must be power of two."
  stop 1
end if 

! dimensionality
if ((rank .lt. 1) .or. (rank .gt. 3)) then
  write(*,*) "ERR: Dimensionality must be 1,2 or 3."
  stop 1
else
  write(*,'(A,I1)') " Number of dimensions: ",rank
end if

! number of steps
if (nstep .lt. 1) then
  write(*,*) "ERR: Number of steps must be bigger than 1."
  stop 1
else
  write(*,'(A,I8)') " Number of steps: ",rank
end if

! params of grid
if (xmin .gt. xmax) then
  write(*,*) "ERR: xmin must be smaller than xmax."
  stop 1
else
  write(*,'(A,F8.4,F8.4)') " xmin, xmax: ", xmin, xmax
end if

! initial wf selection
select case (wf)
  case (0)
    write(*,*) "WF will be generated by program."
  case (1)
    write(*,*) "WF will be read from wf.chk file."
    open(666,file='wf.chk', status='OLD', action='READ',delim='APOSTROPHE', iostat=iost)
    if (iost.ne.0) then
      write(*,*)'ERROR: wf.chk file must be provided'
      write(*,*) iost
      stop 1
    end if
  case default
    write(*,*) "ERR: wf must be either 0 or 1."
end select

! potential
if (analytic) then
  write(*,*) "Potential: analytic"
  if (pot == "") then
    write(*,*) "Potential not provided! Use analytical form. x,y,z for corresponding rank "
    stop 1
  end if
else
  write(*,*) "Potential: provided in file"
end if
               
! number of states
if (nstates < 1) then
  write(*,*) "ERR: number of states must be 1 or more."
  stop 1
else
  if (run .eq. 0 .and. nstates > 1) then
    write(*,*) "ERR: nstates > 1 available only for imag propagation."
    stop 1
  else
    write(*,'(A,I2)') " nstates: ", nstates
  end if
end if

!projecting out rotated wf
if (project_rot .and. (run == 1) .and. (nstates>1)) then
  write(*,*) "Projecting out also 90 degrees rotated wavefunctions due to numeric instabilities"
end if

!field
if (use_field) then
  select case(run)
  case(0)
    write(*,*) "Field: ON"
    if (field == '') then
      write(*,*) "ERR: No field function specified. Set 'field' in input.q."
      stop 1
    else
      write(*,*) "|E(t)| = ", field
    end if
  case(1)
    write(*,*) "ERR: Field cannot be used with imaginary time propagation."
    stop 1
  end select
else 
  if (run == 0) then
    write(*,*) "Field: OFF"
  end if
end if

!printing wavefunction
if (print_wf) then
  write(*,*) "Printing WF: ON"
else
  write(*,*) "Printing WF: OFF"
end if

end subroutine check

end module
